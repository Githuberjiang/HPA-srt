1
00:00:00,000 --> 00:00:11,000
在深入了解原厂ECU的运行之前，我们需要先介绍一些关于电子设备如何运行和编程的一般技术背景理论。 

2
00:00:11,000 --> 00:00:20,000
虽然我们会提到像位（bits）、字节（bytes）、二进制（binary）、十进制（decimal）和十六进制（hexadecimal）这样的术语，但不要感到害怕或被它们吓到。 

3
00:00:20,000 --> 00:00:33,000
我保证，这些概念在解释清楚后相对简单，并且熟悉它们将真正有助于我们在开始寻找和定义ECU内部的地图时让一切变得更加清晰。 

4
00:00:33,000 --> 00:00:37,000
我们将从二进制、十进制和十六进制这些术语开始讲解。 

5
00:00:37,000 --> 00:00:41,000
这些术语指的是具有不同进制的数字系统。 

6
00:00:41,000 --> 00:00:49,000
数字系统的进制本质上是指该系统中可用来表示不同数字的符号数量。 

7
00:00:49,000 --> 00:00:56,000
首先，让我们来看一下十进制系统，因为这是我们在日常生活中最熟悉的系统。 

8
00:00:56,000 --> 00:01:10,000
使用十进制系统可能已经成为你的第二天性，你可能不会去思考它是如何运作的，但我们将通过几个简单的例子来分解它的原理，然后展示如果使用二进制或十六进制这些例子会有何不同。 

9
00:01:10,000 --> 00:01:20,000
十进制系统使用的是10进制，这意味着它有10个不同的符号可用来描述数字，这些符号是从0到9的数字。 

10
00:01:20,000 --> 00:01:26,000
为了展示我们如何使用这些符号，假设我们想要计算一台发动机中的汽缸数量。 

11
00:01:26,000 --> 00:01:36,000
例如，如果我们看一台V8 LS1发动机，并想写下发动机的汽缸数量，我们可以用一个符号来表示，这个符号当然是数字8。 

12
00:01:36,000 --> 00:01:43,000
我们可以用一个符号，因为我们想描述的数字小于我们数字系统的进制。 

13
00:01:43,000 --> 00:01:53,000
但如果我们考虑一台V12发动机，那么汽缸数量现在超过了十进制系统的进制，我们没有单独的符号来描述这个数字。 

14
00:01:53,000 --> 00:02:01,000
这意味着我们需要使用可用符号的组合，在这个例子中是一个1后跟一个2。 

15
00:02:01,000 --> 00:02:14,000
当我们写下这个数字时，我们实际上是在说我们描述的数字是1乘以我们的十进制基数10，加上2乘以1，也就是10加2，当然就是12。 

16
00:02:14,000 --> 00:02:28,000
如果我们接着想描述两台发动机的汽缸总数，我们可以写下一个2后跟一个0，意思是2乘以我们的十进制基数10，加上0乘以1，当然就是20。 

17
00:02:28,000 --> 00:02:41,000
这可能需要一点时间来理解，因为我们通常不需要思考数字12是如何构成的，但回过头去理解每个值的含义是我们进入其他数字系统的关键。 

18
00:02:41,000 --> 00:02:47,000
现在，让我们用十六进制系统来尝试相同的例子，该系统的基数是16。 

19
00:02:47,000 --> 00:02:56,000
这意味着我们现在有16个可用符号来描述数字，包括从0到9的数字，接着是从A到F的字母。 

20
00:02:56,000 --> 00:02:59,000
这些字母分别代表数字10到15。 

21
00:02:59,000 --> 00:03:09,000
描述LS1发动机的汽缸数量时，这个数字仍然小于我们的数字系统基数，因此我们依然可以用一个符号来表示这个数字。 

22
00:03:09,000 --> 00:03:12,000
同样是数字8。 

23
00:03:12,000 --> 00:03:25,000
然而，对于V12的例子来说，我们的十六进制系统基数16现在大于我们想要描述的数字，因此我们可以用一个单一的符号来表示数字12，而在十六进制中，这个符号是C。 

24
00:03:25,000 --> 00:03:35,000
然而，描述两台发动机的汽缸总数时，这个数字再次大于我们的十六进制基数16，因此我们需要再次使用符号的组合。 

25
00:03:35,000 --> 00:03:40,000
在这种情况下，我们会写下数字1后跟数字4。 

26
00:03:40,000 --> 00:03:49,000
在十六进制系统中，这意味着1乘以我们的系统基数16，加上4乘以1，也就是16加4，结果是20。 

27
00:03:49,000 --> 00:04:01,000
这就是很多混淆可能出现的地方，因为当我们看到符号1和4并排放在一起时，我们会立刻想到数字14，因为我们太习惯于使用十进制系统了。 

28
00:04:01,000 --> 00:04:07,000
为了解决这个问题，当我们在十六进制中写下一个数字时，我们会在前面加上“0x”作为前缀。 

29
00:04:07,000 --> 00:04:13,000
因此，要在十六进制中写下数字20，我们会写成0x14。 

30
00:04:13,000 --> 00:04:19,000
回到我们的汽缸计数例子，让我们看看如果我们使用二进制系统，这些例子会有怎样的不同。 

31
00:04:19,000 --> 00:04:28,000
二进制的基数是2，这意味着我们只有两个不同的符号可用来描述不同的数字，也就是数字0和1。 

32
00:04:28,000 --> 00:04:38,000
立刻可以看到，LS1发动机的汽缸数量已经超过了我们的数字系统基数，因此我们需要使用可用符号的组合。 

33
00:04:38,000 --> 00:04:42,000
在这种情况下，我们会写下数字1，后面跟着三个0。 

34
00:04:42,000 --> 00:04:54,000
重要的是要理解，我们数字中的每一列表示该列中的符号乘以系统基数的次数，然后将所有结果相加以得到总数。 

35
00:04:54,000 --> 00:05:04,000
这听起来很复杂，但你可能还记得在学校学习十进制系统时，1的列、10的列、100的列等等。 

36
00:05:04,000 --> 00:05:11,000
如果我们在十进制中写下138，这意味着1乘以10的两次方，也就是1乘以100。 

37
00:05:11,000 --> 00:05:17,000
再加上3乘以10，也就是30，再加上8，总共是138。 

38
00:05:17,000 --> 00:05:21,000
对于我们的二进制例子来说也是一样，只不过我们的基数现在是2。 

39
00:05:21,000 --> 00:05:38,000
所以1, 0, 0, 0表示1乘以2的三次方，也就是1乘以8，加上0乘以2的两次方，加上0乘以2，加上0，总共是8加上三个0，或者直接是8。 

40
00:05:38,000 --> 00:05:54,000
对于我们的V12例子来说，12个汽缸可以写成1100，意思是1乘以2的三次方，也就是8，加上1乘以2的两次方，也就是4，再加上0和0，总共是12。 

41
00:05:54,000 --> 00:06:04,000
同样地，如果我们只是看到1100写在那儿，我们会本能地将其读作一千一百，因为我们太习惯于十进制系统了。 

42
00:06:04,000 --> 00:06:13,000
所以，为了明确我们写的是一个二进制数字，我们会在前面加上“0b”作为前缀，因此我们会写成0b1100。 

43
00:06:13,000 --> 00:06:21,000
要描述两台发动机的汽缸总数，我们会写成0b10100。 

44
00:06:21,000 --> 00:06:31,000
这表示1乘以2的四次方，也就是16，加上0，加上1乘以2的两次方，也就是4，再加上0，再加上0。 

45
00:06:31,000 --> 00:06:34,000
或者说16加4，当然就是20。 

46
00:06:34,000 --> 00:06:41,000
如果你没有计算机背景，那么你现在可能正盯着屏幕发呆，嘴巴张得大大的，这可以理解。 

47
00:06:41,000 --> 00:06:54,000
我承认，我们这里讲得有点快，但我建议你多回顾几遍这个模块，拿些纸和笔出来，练习这些不同的系统和列，直到你能理解它们。 

48
00:06:54,000 --> 00:07:05,000
其实这并不太难，但不幸的是，你到目前为止的一生都在用十进制系统，所以要理解这些不同的系统，需要一点“去习惯化”的过程。 

49
00:07:05,000 --> 00:07:16,000
如果你还是感到困惑，幸运的是，有一个非常常见的工具可以让你轻松地在这些数字系统之间进行转换，那就是Windows计算器应用程序。 

50
00:07:16,000 --> 00:07:29,000
打开计算器应用程序并将模式切换到“程序员”模式，你就可以选择以二进制、十进制或十六进制输入一个数字，并查看它在其他数字系统中的表示方式。 

51
00:07:29,000 --> 00:07:45,000
现在试一下，如果我们将计算器切换到程序员模式，并将数字系统设置为十六进制，然后输入14，你会看到这与十进制中的20和二进制中的10100是一样的。 

52
00:07:45,000 --> 00:07:54,000
所有这些表示方式的意思完全相同，都是数字20，只是它们以不同的数字基数系统显示出来。 

53
00:07:54,000 --> 00:08:09,000
在现实世界中，我们需要了解二进制、十进制和十六进制的原因是，我们可以用不同的方式显示ECU数据的内容，能够理解你所看到的内容以及如何在不同系统之间转换是很有帮助的。 

54
00:08:09,000 --> 00:08:16,000
幸运的是，我们不需要在二进制或十六进制中进行任何复杂的数学运算，所以对它们的完全理解并不是关键。 

55
00:08:16,000 --> 00:08:20,000
这里的信息量有点大，所以让我们快速回顾一下。 

56
00:08:20,000 --> 00:08:27,000
记住，十进制、十六进制和二进制只是不同的数字系统，它们有不同的基数。 

57
00:08:27,000 --> 00:08:35,000
例如，我们最熟悉的十进制系统使用的是基数10，而十六进制是基数16，二进制是基数2。 

58
00:08:35,000 --> 00:08:42,000
为了避免混淆，我们使用前缀0x或0b来表示一个十六进制或二进制数字。 

59
00:08:42,000 --> 00:08:52,000
如果你感到困惑，你可以随时使用计算器的程序员模式，在不同的数字系统之间进行转换。

60
00:08:52,000 --> 00:08:58,000
比特（Bits）和字节（Bytes）是我们在讨论电子设备如何读取和存储数据时所使用的术语。 

61
00:08:58,000 --> 00:09:04,000
你需要很好地理解这些术语的含义，因为在课程的其余部分我们会经常使用它们。 

62
00:09:04,000 --> 00:09:14,000
尽管一开始它们可能看起来有点抽象甚至令人困惑，但当你在课程的实践部分中开始处理它们时，这些概念会逐渐变得清晰，并成为你的习惯。 

63
00:09:14,000 --> 00:09:21,000
比特（Bit）只是电子设备可以解释和存储的最小单元信息。 

64
00:09:21,000 --> 00:09:29,000
它是一个单一的二进制数字，我们已经学过，它的最大值是1，最小值是0，并且它只能有这两个值。 

65
00:09:29,000 --> 00:09:34,000
有时这些值也被称为“开”和“关”或“高”和“低”。 

66
00:09:34,000 --> 00:09:47,000
二进制是计算机和电子设备的语言，尽管我们通常会以十进制的方式思考存储在特定映射中的数据，但这些数据必须在某个阶段被转换为二进制，以便ECU可以处理它们。 

67
00:09:47,000 --> 00:09:58,000
另一方面，字节（Byte）只是由八个比特组成的一个组。由于每个比特是一个二进制数字，这意味着一个字节是一个由八位组成的二进制数。 

68
00:09:58,000 --> 00:10:04,000
一个字节的最大值是255，最小值是0。 

69
00:10:04,000 --> 00:10:15,000
为了验证这一点，我们将打开计算器应用程序，输入可能的最大八位二进制数，也就是八个1，然后看看它在十进制和十六进制中的转换结果。 

70
00:10:15,000 --> 00:10:22,000
你可以看到，这个值在十进制中是255，而在十六进制中是FF。 

71
00:10:22,000 --> 00:10:43,000
那么，如果我们习惯用十进制来思考数据，而电子设备需要使用二进制，为什么在课程的上一部分我们还介绍了十六进制系统呢？ 如果你查看计算器中最大的八位二进制数值，你会发现它与十六进制值FF相同。 

72
00:10:43,000 --> 00:10:56,000
这是我们用两个十六进制数字可以表示的最大值。 因此，现在我们的八位二进制数和两位十六进制数字具有相同的最大值和最小值。 

73
00:10:56,000 --> 00:11:10,000
这为我们提供了一个很好的捷径，当我们想表示一个字节的数据时，可以将其从八位二进制数转换为十六进制，并用两个数字表示，这样更快也更简单。 

74
00:11:10,000 --> 00:11:18,000
当我们在WinOLS中查看原始映射值时，可以选择以十进制、十六进制或二进制的方式显示这些数据。 

75
00:11:18,000 --> 00:11:21,000
一个字节可以表示的最大值是非常重要的。 

76
00:11:21,000 --> 00:11:26,000
我们刚刚发现，这个值在十进制中是255，所以让我们试着理解这一点的意义。 

77
00:11:26,000 --> 00:11:33,000
假设我们想表示油门踏板的位置，这显然是一个从0到100%的值。 

78
00:11:33,000 --> 00:11:38,000
在这种情况下，我们可以很容易地用八位或一个字节来表示它。 

79
00:11:38,000 --> 00:11:47,000
在这种情况下，值为0表示油门关闭或0%，而值为255表示全开油门或100%。 

80
00:11:47,000 --> 00:12:02,000
为了将原始值255转换为油门位置，我们可以将原始值除以2.55。 例如，255除以2.55等于100，也就是100%的油门开度。 

81
00:12:02,000 --> 00:12:09,000
另一个重要的部分不仅是我们可以表示的最大值，还有分辨率。 

82
00:12:09,000 --> 00:12:21,000
我的意思是，如果我们用一个八位数表示油门位置，那么每一步的变化就是1除以2.55，或者大约是0.4%的油门开度变化。 

83
00:12:21,000 --> 00:12:28,000
对于油门位置的分辨率来说，这可能是完全可以接受的，但让我们考虑一下如果我们想表示发动机转速会发生什么。 

84
00:12:28,000 --> 00:12:32,000
假设我们有一台发动机，它的转速可以达到8000 RPM。 

85
00:12:32,000 --> 00:12:37,000
显然，255并不是表示8000这个值的一个好方法，但我们可以做到。 

86
00:12:37,000 --> 00:12:43,000
如果我们将8000除以255，我们会得到一个值31.37。 

87
00:12:43,000 --> 00:12:51,000
通过这种方式，如果我们用31.37作为因子来乘以我们的原始值，就可以覆盖所需的转速范围。 

88
00:12:51,000 --> 00:12:56,000
255乘以31.37正好等于8000。 

89
00:12:56,000 --> 00:13:04,000
到目前为止，一切看起来都不错，然而，这会导致非常糟糕的分辨率，这对几乎所有ECU操作来说都是不可接受的。 

90
00:13:06,000 --> 00:13:14,000
这里我们的意思是，每次将八位二进制值增加1，转速（RPM）就会跳跃31。 

91
00:13:14,000 --> 00:13:17,000
这显然不是我们想要的发动机精细控制方式。 

92
00:13:17,000 --> 00:13:24,000
那么我们如何改善这种情况呢？方法很简单，就是使用16位数字代替8位数字。 

93
00:13:24,000 --> 00:13:32,000
既然我们已经知道一个字节有八位，那么16位自然就是两个字节。 

94
00:13:32,000 --> 00:13:43,000
使用16位会大幅增加我们可以表示的最大值，现在我们可以表示从0到65,535的十进制数字。 

95
00:13:43,000 --> 00:13:53,000
如果你想用十六进制表示这个值，那么它当然是FFFF，因为我们已经知道单个字节的最大十六进制值是FF。 

96
00:13:53,000 --> 00:13:56,000
现在我们只是将第二个字节添加到第一个字节上。 

97
00:13:56,000 --> 00:13:59,000
那么，让我们来总结一下我们学到的内容。 

98
00:13:59,000 --> 00:14:06,000
一个八位值的上限是255，而一个16位值的上限是65,535。 

99
00:14:06,000 --> 00:14:16,000
回到我们的发动机转速示例，如果我们将8000除以65,535，我们得到0.1，这意味着当我们使用16位或两个字节时，分辨率现在是0.1 RPM。 

100
00:14:22,000 --> 00:14:28,000
对于我们的用途来说，这已经足够了，因此这将是表示发动机转速的一个很好的方法。 

101
00:14:28,000 --> 00:14:41,000
虽然65,535是一个很大的数字，但在某些情况下，我们可能仍然希望以非常高的精度表示较大的十进制值，而16位可能就不够用了。 

102
00:14:41,000 --> 00:14:46,000
当然，我们可以升级到32位，也就是四个字节组合在一起。 

103
00:14:46,000 --> 00:14:57,000
这样我们就可以精确地表示从0到2,147,483,647的十进制值。 

104
00:14:57,000 --> 00:15:07,000
在ECU调校中，只有有限的应用需要这种精度，因此32位的值相对不常见，但确实存在。 

105
00:15:07,000 --> 00:15:13,000
最后，我们还有浮点数，这稍微复杂一些。 

106
00:15:13,000 --> 00:15:19,000
到目前为止，我们讨论了8位、16位和32位的数字，它们都是整数或整型数值。 

107
00:15:19,000 --> 00:15:27,000
这意味着不需要处理小数点，并且从ECU的角度来看，任何涉及整数的映射都非常简单。 

108
00:15:27,000 --> 00:15:36,000
而当涉及到浮点数时，我们现在讨论的是一个包含小数点的数字，并且这个小数点可以位于数字中的任何位置。 

109
00:15:36,000 --> 00:15:43,000
换句话说，在小数点之前和之后可以有不确定数量的数字或位。 

110
00:15:43,000 --> 00:15:52,000
不深入细节的话，这会显著影响ECU对浮点数进行数学运算的方式。 

111
00:15:52,000 --> 00:15:57,000
ECU处理浮点数的方法是将其存储为科学计数法的形式。 

112
00:15:57,000 --> 00:16:07,000
这意味着它会编码所需的位来表示数字的整数部分，然后编码所需的位来表示小数部分，也就是小数点后的部分。 

113
00:16:07,000 --> 00:16:13,000
接着，ECU会添加一个指数，用于将科学计数法转换回原始数字。 

114
00:16:13,000 --> 00:16:26,000
这意味着每当ECU需要对浮点数进行数学运算时，它需要拆分各个部分，规范化指数部分，然后对每个部分进行运算，最后将它们重新组合成结果。 

115
00:16:26,000 --> 00:16:39,000
如果上面这段听起来像是外语，不用担心，因为幸运的是，我们并不需要深入理解这个过程，只需要知道浮点数确实存在即可。 

116
00:16:39,000 --> 00:16:45,000
同时，理解ECU表示数值的不同方式及其影响也很重要。 

117
00:16:45,000 --> 00:16:56,000
为了高效利用处理器并提高处理速度，使用尽可能少的位数，同时提供足够的精度，是一大优势。 

118
00:16:56,000 --> 00:17:04,000
因此，浮点数是最占用处理器资源的，其次是32位、16位，最后是8位。 

119
00:17:04,000 --> 00:17:13,000
因此，浮点数和32位值很少是必要的，我们主要处理的是8位和16位的数值。 

120
00:17:13,000 --> 00:17:22,000
当然，随着处理器变得越来越复杂，我们可以预期这种情况会有所改变，但目前，浮点数和32位值仍然是例外，而不是常态。 

121
00:17:22,000 --> 00:17:32,000
希望你到现在还没有睡着，因为本模块中最重要的内容是一些我们需要理解和识别的特定数值。 

122
00:17:32,000 --> 00:17:49,000
这些数值与ECU表示我们希望在映射中看到的十进制值的方式有关，它们是将原始数值转换为可识别数据（如转速、喷油量、扭矩、节气门位置等）的关键因素。 

123
00:17:49,000 --> 00:17:56,000
我们已将这些数值作为附件包含在本模块中，建议你打印出来，并在查找映射时将其用作参考卡片。 

124
00:17:56,000 --> 00:18:02,000
例如，如果我们考虑二进制系统，卡片上会有一些数值是以倍数递增的。 

125
00:18:02,000 --> 00:18:15,000
2、4、8，一直到8192、16,834、32,768，最后是65,536。 

126
00:18:15,000 --> 00:18:19,000
希望这些数字中的一些听起来已经开始变得熟悉了。 

127
00:18:19,000 --> 00:18:25,000
例如，65,536是16位数字中可表示的最大值。 

128
00:18:25,000 --> 00:18:35,000
这之所以重要，是因为我们会开始在查找的映射中识别这些原始数值，并利用它们来决定合适的转换或缩放因子。 

129
00:18:35,000 --> 00:18:44,000
在我们关于OLS的介绍中，我曾举过一个节气门位置的例子，其使用的原始值就是65,535。 

130
00:18:44,000 --> 00:18:52,000
这当然可以立即识别为16位数字的最大值，并且我们在参考卡片上也能看到相同的数值。 

131
00:18:52,000 --> 00:18:59,000
需要注意的是，这里有一个数字上的小差异，这仅仅是因为我们从零开始计数。 

132
00:18:59,000 --> 00:19:03,000
因此，最大值是65,535。 

133
00:19:03,000 --> 00:19:11,000
然而，这实际上代表了65,536个离散值，这是一个微妙但重要的区别。 

134
00:19:11,000 --> 00:19:18,000
无论如何，一旦我们认识到这是一个重要的数值，我们就可以将其用作转换因子的除数。 

135
00:19:18,000 --> 00:19:29,000
需要注意小数点的位置，以确保最终结果在0到100%的范围内，这样我们就得到了一个合理范围内的节气门位置值。 

136
00:19:29,000 --> 00:19:34,000
本模块的内容确实深入得很快，所以在继续之前，我们先回顾一下关键点。 

137
00:19:34,000 --> 00:19:45,000
记住，一个字节包含8位，可以用两个十六进制值表示，这比使用二进制或十进制系统更快捷。 

138
00:19:45,000 --> 00:19:59,000
由于一个字节的最大值是十进制的255，这会影响我们想要表示的数值的分辨率。虽然它对于节气门位置之类的参数已经足够，但对于像转速这样的通道，我们需要更高的分辨率。 

139
00:19:59,000 --> 00:20:10,000
这里的简单解决方案是使用两个字节，这样其最大值就变成十进制的65,535。 

